<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RAID级别介绍和配置指南 | Akisec</title><meta name="author" content="3kk0"><meta name="copyright" content="3kk0"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RAID 概述RAID（独立磁盘冗余阵列）是一种通过虚拟化技术将多个硬盘组合成一个逻辑存储组，以同时提升存储性能和数据冗余的方法。简单来说，RAID 将多块磁盘联合起来对外呈现为一个更大的磁盘，操作系统将其视为单一的存储设备。根据不同的 RAID 层级，数据会以不同方式分布到各个硬盘上。每种 RAID 级别都有其特定的实现方式和理论上的优缺点，在提高数据可靠性和读写性能两方面各有侧重。 RAID">
<meta property="og:type" content="article">
<meta property="og:title" content="RAID级别介绍和配置指南">
<meta property="og:url" content="https://wiki.stxwer.top/2025/05/26/raid/index.html">
<meta property="og:site_name" content="Akisec">
<meta property="og:description" content="RAID 概述RAID（独立磁盘冗余阵列）是一种通过虚拟化技术将多个硬盘组合成一个逻辑存储组，以同时提升存储性能和数据冗余的方法。简单来说，RAID 将多块磁盘联合起来对外呈现为一个更大的磁盘，操作系统将其视为单一的存储设备。根据不同的 RAID 层级，数据会以不同方式分布到各个硬盘上。每种 RAID 级别都有其特定的实现方式和理论上的优缺点，在提高数据可靠性和读写性能两方面各有侧重。 RAID">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.stxwer.top/2025/05/26/6834259507497.webp">
<meta property="article:published_time" content="2025-05-26T08:21:19.000Z">
<meta property="article:modified_time" content="2025-05-26T08:26:56.935Z">
<meta property="article:author" content="3kk0">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Raid">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.stxwer.top/2025/05/26/6834259507497.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RAID级别介绍和配置指南",
  "url": "https://wiki.stxwer.top/2025/05/26/raid/",
  "image": "https://pic.stxwer.top/2025/05/26/6834259507497.webp",
  "datePublished": "2025-05-26T08:21:19.000Z",
  "dateModified": "2025-05-26T08:26:56.935Z",
  "author": [
    {
      "@type": "Person",
      "name": "3kk0",
      "url": "https://wiki.stxwer.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wiki.stxwer.top/2025/05/26/raid/index.html"><link rel="preconnect" href="https://cdn.bootcdn.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.bootcdn.net/font-awesome/6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.bootcdn.net/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RAID级别介绍和配置指南',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script async defer src="https://status.stxwer.top/tracker.js" data-website-id="cmanjtwhw0001osvicvj0lelh"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://pic.stxwer.top/2025/05/12/6821c234b7c34.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 玩法</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/windows/"><i class="fa-fw fab fa-windows"></i><span> Windows</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic.stxwer.top/2025/05/26/6834259507497.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Akisec</span></a><a class="nav-page-title" href="/"><span class="site-name">RAID级别介绍和配置指南</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 玩法</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/windows/"><i class="fa-fw fab fa-windows"></i><span> Windows</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RAID级别介绍和配置指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-26T08:21:19.000Z" title="发表于 2025-05-26 16:21:19">2025-05-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-26T08:26:56.935Z" title="更新于 2025-05-26 16:26:56">2025-05-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>66分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="waline-pageview-count" data-path="/2025/05/26/raid/"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/05/26/raid/#post-comment"><span class="waline-comment-count" data-path="/2025/05/26/raid/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="RAID-概述"><a href="#RAID-概述" class="headerlink" title="RAID 概述"></a>RAID 概述</h2><p>RAID（独立磁盘冗余阵列）是一种通过虚拟化技术将多个硬盘组合成一个逻辑存储组，以同时提升存储性能和数据冗余的方法。简单来说，RAID 将多块磁盘联合起来对外呈现为一个更大的磁盘，操作系统将其视为单一的存储设备。根据不同的 RAID 层级，数据会以不同方式分布到各个硬盘上。每种 RAID 级别都有其特定的实现方式和理论上的优缺点，在提高数据可靠性和读写性能两方面各有侧重。</p>
<p>RAID 最初定义了多个标准层级（RAID 0～RAID 5 等），后来又出现了更高层级、组合级别和厂商特定的 RAID 实现。需要注意的是，RAID 并不是备份手段——虽然某些 RAID 级别提供冗余保护，能够在硬盘故障时防止数据丢失，但如果发生数据误删或灾难性损坏，RAID 无法替代离线备份。RAID 的主要目的在于提供磁盘容错能力和提高 I&#x2F;O 性能（如增加吞吐量、提升 IOPS）。</p>
<p>一般情况下，RAID 常用于服务器和存储系统，但随着磁盘价格降低和主板集成 RAID 功能的普及，个人用户在需要大容量或高性能存储时也开始采用 RAID。</p>
<h2 id="RAID-级别分类"><a href="#RAID-级别分类" class="headerlink" title="RAID 级别分类"></a>RAID 级别分类</h2><p>RAID 级别通常以数字编号区分不同的数据组织方式，包括标准 RAID 级别（如 RAID 0, 1, 2, 3, 4, 5, 6 等）和组合 &#x2F; 嵌套 RAID 级别（如 RAID 10, 0+1, 50, 60 等）。此外，还有厂商或特定文件系统实现的变种（例如 NetApp 的 RAID-DP、ZFS 文件系统的 RAID-Z 等）。</p>
<p>以下将详细介绍常见和非常见的各 RAID 级别，包括其空间利用计算方式、性能特点、容错与恢复能力、优缺点以及典型应用场景，并提供配置方法和 RAID 选择指南。</p>
<h2 id="各-RAID-级别详解"><a href="#各-RAID-级别详解" class="headerlink" title="各 RAID 级别详解"></a>各 RAID 级别详解</h2><h3 id="RAID-0-–-条带化存储（Striping）"><a href="#RAID-0-–-条带化存储（Striping）" class="headerlink" title="RAID 0 – 条带化存储（Striping）"></a>RAID 0 – 条带化存储（Striping）</h3><p>RAID 0 通过数据条带化（Striping）实现性能最大化。它将数据分割成块，交替分布在两个或更多磁盘上，使所有磁盘可以并行读写。因此 RAID 0 能够提供线性提升的读写性能：如果有 n 块磁盘，理论上顺序读写速度可以接近单盘的 n 倍。RAID 0 不存储任何校验或冗余信息，没有冗余和容错能力，这意味着其中任意一块磁盘发生故障都会导致整个阵列的数据全部丢失。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 0 的可用总容量是所有成员磁盘容量的总和。例如，使用 n 块容量相同的硬盘组成 RAID 0，可用容量 &#x3D; n × 单盘容量。没有任何容量损失在冗余上（冗余开销为 0）。</li>
<li><strong>性能特性</strong>：RAID 0 在所有 RAID 级别中读写性能最优。读写操作可以由多盘并行处理，顺序吞吐量和并发 I&#x2F;O 能力都成倍提高。对于大文件的顺序读写，吞吐量近似于单盘的 n 倍；对于随机 I&#x2F;O，由于没有校验计算，也无额外开销，性能主要取决于并发 I&#x2F;O 负载能否有效利用多磁盘并行性。</li>
<li><strong>冗余与容错</strong>：无冗余。任意一盘故障即阵列崩溃，故障耐受度 &#x3D; 0（不可容忍任何磁盘损坏）。数据恢复几乎不可能，只能通过备份还原，因为 RAID 0 没有校验数据可用于重建。</li>
<li><strong>优点</strong>：实现最大的存储利用率和最高的 I&#x2F;O 性能；成本最低（无额外冗余磁盘）。</li>
<li><strong>缺点</strong>：数据安全性极低，单盘故障会造成全部数据丢失；MTBF（平均无故障时间）实际上比单盘更低（因为更多盘带来更高故障概率）。</li>
<li><strong>典型应用场景</strong>：适用于对性能要求极高且能接受数据丢失风险的场合，例如视频剪辑的高速缓存 &#x2F; 临时处理盘、非关键性的临时计算空间等。这些场景通常有独立的数据备份或源文件，可在阵列故障后重新获取数据。</li>
</ul>
<h3 id="RAID-1-–-磁盘镜像（Mirroring）"><a href="#RAID-1-–-磁盘镜像（Mirroring）" class="headerlink" title="RAID 1 – 磁盘镜像（Mirroring）"></a>RAID 1 – 磁盘镜像（Mirroring）</h3><p>RAID 1 通过磁盘镜像实现数据冗余，即将相同的数据实时写入两块或多块硬盘中。每写入一份数据都会同步复制到镜像盘上，从而在所有成员盘保存完整的副本。RAID 1 提供了最高的数据安全性：只要阵列中至少有一块磁盘完好，数据即完整无损。典型情况下 RAID 1 由两块磁盘组成镜像对（也可扩展为多盘镜像，以增加读取性能或额外备份副本）。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 1 可用容量等于其中最小容量磁盘的容量（相当于仅利用了一块盘的容量）。例如，两块 4TB 镜像，则可用总容量为 4TB；若镜像由大小不同磁盘组成，则以较小磁盘容量为准。由于每份数据都写入两份，磁盘利用率仅 50%（两盘情况下）；用更多磁盘做多重镜像时，利用率更低，是所有 RAID 中磁盘利用率最低的级别。</li>
<li><strong>性能特性</strong>：RAID 1 的读取性能良好。因为每块盘上都有完整数据，控制器 &#x2F; 操作系统可以将读取任务分散到多个盘并行完成。在理想情况（多线程读取或智能调度）下，读取吞吐量可接近 n 倍于单盘（n 为镜像盘数）。实际中对于单一顺序读取，部分实现也能通过交替从不同盘读取来略微提升速度。写入性能略低于单一硬盘：需要对每块镜像盘都写入一次，但这些写操作可以并行进行，因此总体写入速度接近单盘水平，开销主要是同步多盘写入的微小延迟。</li>
<li><strong>冗余与容错</strong>：RAID 1 具有最高容错能力。只要有一块磁盘正常，数据即不丢失。在两盘镜像中，可容忍 1 盘故障；在 n 盘镜像中，最多可容忍 n-1 块磁盘同时故障（只剩一盘仍可运行）。故障盘更换后，阵列会通过将剩余完好盘的数据拷贝到新盘来重建镜像，恢复满冗余状态。重建过程相对简单（为整盘复制），速度取决于磁盘大小和接口带宽。</li>
<li><strong>优点</strong>：提供极高的数据安全性和可靠性，是容错能力最强的 RAID 级别；读取性能有提升（尤其在多用户场景下并发读取效能好）；重建逻辑简单。</li>
<li><strong>缺点</strong>：存储利用率低（50% 或更低）；成本高昂（有一半以上的存储投入用于冗余）；写入开销略有增加；无法容忍数据不一致（需确保镜像实时同步，否则可能出现镜像不同步问题，但一般 RAID 控制器会处理同步）。</li>
<li><strong>典型应用场景</strong>：适用于数据安全要求最高、小容量且随机写入较多的场景。例如操作系统盘、数据库日志盘、小型企业或个人的重要数据存储、服务器系统盘等。很多个人 NAS 和企业级存储会采用 RAID 1 来保证磁盘任一损坏时数据不丢失。在只有两块磁盘的情况下，RAID 1 往往是唯一可以提供冗余保护的选择。</li>
</ul>
<h3 id="RAID-2-–-汉明码校验（Hamming-Code-ECC）"><a href="#RAID-2-–-汉明码校验（Hamming-Code-ECC）" class="headerlink" title="RAID 2 – 汉明码校验（Hamming Code ECC）"></a>RAID 2 – 汉明码校验（Hamming Code ECC）</h3><p>RAID 2 是早期的一种实验性 RAID 级别，利用汉明码（Hamming Code）的错误校验和纠正机制来提供数据冗余。它可以看作对 RAID 0 的改良：数据在写入前会编码拆分成位（bit）条带，分散写入多个数据盘；同时计算错误校正码（ECC）存放在额外的校验盘上。汉明码能够检测并纠正单个位错误，因此 RAID 2 可以容忍单一磁盘故障（相当于一整个盘位的数据丢失，可被 ECC 纠正）。若同时有两块或以上磁盘出问题，超出汉明码纠错能力，则阵列数据无法完全恢复。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 2 需要预留多个磁盘用于存放 ECC 校验位，具体数量取决于数据盘数量和汉明码算法（汉明码需要若干校验位覆盖特定位宽的数据位）。因此阵列总容量略小于数据盘容量之和，而且比 RAID 5&#x2F;6 这类只需 1-2 盘校验的方案开销更大。例如一个简单实现可能用 4 个数据盘 + 3 个校验盘（共 7 盘）来组织汉明码，使得可用容量约为 4 盘总容量，冗余开销较高。总的来说，RAID 2 可用容量会因为存储 ECC 信息而“比原始数据大一些”。</li>
<li><strong>性能特性</strong>：RAID 2 进行位级别的条带化，所有磁盘（数据盘和校验盘）在每次读写中都参与操作。一段数据通常分散到位粒度，需要所有盘同步读 &#x2F; 写才能组合 &#x2F; 校验数据。这意味着 RAID 2 无法独立访问单盘完成 I&#x2F;O，即使很小的数据读写也需要整个阵列协同，这使其随机 I&#x2F;O 性能较差、延迟较高。然而在顺序传输时，多盘并行仍带来带宽提升。此外，ECC 计算会带来额外的计算开销，纯软件实现时对 CPU 有较大负载。</li>
<li><strong>冗余与容错</strong>：可容忍 1 块磁盘故障（单盘数据可由 ECC 纠正）。当一盘失效时，阵列可通过剩余数据盘和校验盘的汉明码计算重建出丢失的数据位，纠错过程类似于内存 ECC 校验纠正单比特错误的原理。一旦故障盘更换，系统可重新计算该盘的所有 ECC 或数据位进行恢复。如果多于 1 盘同时故障，纠错失败，阵列将崩溃无法正常使用。</li>
<li><strong>优点</strong>：引入了先进的纠错码（ECC），相较早期只条带化的方案，有一定的容错能力；在特定实现中，读性能和顺序吞吐仍能受益于多盘并行。</li>
<li><strong>缺点</strong>：实现复杂，需专用硬件支持高速的位级条带和 ECC 计算；存储开销大（需要多个校验盘）；随机 I&#x2F;O 性能不佳；实际应用极少。多数现代 RAID 系统没有采用 RAID 2。</li>
<li><strong>典型应用场景</strong>：RAID 2 主要具有历史意义，现代实践中几乎找不到实现的 RAID 2 控制器或软件。它更多作为冗余编码思想的展示，用于教科书或研究。现实中更高效的 RAID 5&#x2F;6 等取代了 RAID 2。</li>
</ul>
<h3 id="RAID-3-–-字节交错奇偶校验（Byte-Interleaved-Parity）"><a href="#RAID-3-–-字节交错奇偶校验（Byte-Interleaved-Parity）" class="headerlink" title="RAID 3 – 字节交错奇偶校验（Byte-Interleaved Parity）"></a>RAID 3 – 字节交错奇偶校验（Byte-Interleaved Parity）</h3><p>RAID 3 采用字节（或位）交错的条带化方式，并在一个专用奇偶校验盘上存储校验信息。和 RAID 2 类似，RAID 3 也需要所有成员盘同步工作来完成 I&#x2F;O 操作，但不同的是 RAID 3 使用简单的异或（XOR）校验而非复杂 ECC 码。这意味着数据按字节 &#x2F; 位分布在多个数据盘上，而每个条带的奇偶校验位集中存储在专门的 Parity 盘上。RAID 3 能容忍单盘故障，通过奇偶校验盘的数据与其余数据盘内容进行异或运算即可重建丢失数据。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 3 至少需要 3 块磁盘（2 个数据盘 + 1 个校验盘）。可用容量 &#x3D; (总磁盘数 - 1) × 单盘容量。也就是说，有一整块盘的容量用于存储奇偶校验，冗余开销约占总容量的 1&#x2F;n（n 为磁盘数）。例如 4 盘 RAID 3 的可用容量为 3 盘数据总和，25% 容量用于校验。</li>
<li><strong>性能特性</strong>：RAID 3 的顺序读写性能很好。由于数据被按字节条带到所有磁盘上，读取或写入大块顺序数据时，所有盘可并行传输，不同字节在不同盘上同步读 &#x2F; 写，整体吞吐量接近多盘合计带宽。然而，随机访问性能较差：因为即使读取少量数据，也需要所有数据盘定位并同时读取各自的部分，再组合成完整数据。这导致小 I&#x2F;O 请求无法在盘间并行服务，响应时间受限于阵列中最慢的一块盘。另外，每次写入除了更新数据盘上的对应字节，还需要更新奇偶校验盘，会频繁地对校验盘进行操作。</li>
<li><strong>冗余与容错</strong>：可容忍 1 块磁盘故障（数据盘或奇偶盘任意一块）。当任一数据盘损坏时，其上数据可由剩余所有数据盘字节异或结果与校验盘数据计算恢复；当校验盘损坏时，没有数据实际丢失，只需重建新的校验盘内容即可。RAID 3 发生单盘故障后阵列能继续工作，但所有 I&#x2F;O 都会受影响，因为缺盘时每次访问仍需计算或跳过缺失部分的数据，性能下降明显。更换上新盘后，系统通过剩余数据计算重建校验或数据内容，恢复到冗余保护状态。</li>
<li><strong>优点</strong>：顺序读写性能高，适合大型流式数据传输；提供基本容错能力（单盘）；实现原理比 RAID 2 简单（仅用 XOR 校验）；磁盘利用率相对可接受（浪费一盘容量）。</li>
<li><strong>缺点</strong>：随机 I&#x2F;O 性能低，每次操作都牵涉所有磁盘；存在单一奇偶校验盘瓶颈——校验盘在每次写入时都要更新，成为全阵列最繁忙的盘，可能限制写性能并加速该盘磨损；只能容忍单盘故障，无法应对双盘失效。</li>
<li><strong>典型应用场景</strong>：RAID 3 适合以顺序读写为主的场景，如流媒体服务器、视频编辑和播放系统等，在这类场景下需要同时读取大量连续数据。但是由于随机性能不佳和校验盘瓶颈，RAID 3 在通用计算环境中并不常见，已被 RAID 5 等更灵活的方案取代。目前少数专用存储设备或老旧系统可能实现 RAID 3，但新项目中几乎不再选用。</li>
</ul>
<h3 id="RAID-4-–-独立块奇偶校验（Dedicated-Parity-with-Block-Striping）"><a href="#RAID-4-–-独立块奇偶校验（Dedicated-Parity-with-Block-Striping）" class="headerlink" title="RAID 4 – 独立块奇偶校验（Dedicated Parity with Block Striping）"></a>RAID 4 – 独立块奇偶校验（Dedicated Parity with Block Striping）</h3><p>RAID 4 与 RAID 3 类似，也采用一个专门的奇偶校验盘，但数据不是按字节而是按块（Block）进行条带化。这意味着每个磁盘可以独立存储完整的数据块，不同块分散在不同磁盘上，同时在一个固定磁盘上为对应条带存储奇偶校验信息。RAID 4 的关键区别在于块级条带允许每次 I&#x2F;O 定位并作用于单个磁盘上的完整数据块，从而改进了并发性能。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 4 至少需要 3 盘（2 数据 + 1 校验）。可用容量与 RAID 3 相同，即 &#x3D; (n-1)× 单盘容量。一块盘的容量专用于奇偶校验信息，典型实现中各条带的校验块都在这同一盘上。</li>
<li><strong>性能特性</strong>：RAID 4 的读取性能相对于 RAID 3 有显著提升。由于数据按块存储，不同块可能在不同磁盘，因此对不同块的读取可以由不同磁盘独立完成——例如多个用户并发读取不同文件时，I&#x2F;O 请求可以分散到多个盘，各自并行服务，从而提高并发吞吐量。这种独立磁盘读能力是 RAID 3 不具备的（RAID 3 所有 I&#x2F;O 都需全盘参与）。顺序读的性能在 RAID 4 中与 RAID 3 类似（多盘并行）；随机读因能够单盘完成，性能接近单盘随机读乘以并发盘数。写入性能则仍然受到专用校验盘的影响：每次写入一个数据块，需要同时访问校验盘来更新对应校验块。流程通常为“读出旧数据块和对应旧校验块 -&gt; 用新数据计算新的校验值 -&gt; 写入新数据块和新校验块”，由此校验盘的写操作频率极高。结果是奇偶盘成为瓶颈，限制写入吞吐，并导致该盘负载远高于数据盘。</li>
<li><strong>冗余与容错</strong>：可容忍单盘故障（与 RAID 3 相同）。数据盘故障可通过余下所有数据盘和校验盘重算恢复，校验盘故障则只需重建校验信息。单盘失效期间，阵列可以运行但性能降低，需要对每次相关读请求进行额外计算。重建新盘过程与 RAID 3 一致，需要遍历整个阵列计算缺失盘的数据或校验。</li>
<li><strong>优点</strong>：支持并行读操作，随机读取性能较好；简单易实现（XOR 校验）；容量利用率与 RAID 3 相同但提供了更高读取并发度。</li>
<li><strong>缺点</strong>：写入性能受限于校验盘瓶颈，每次写操作都涉及校验盘更新；无法容忍多盘故障；在高 IO 写入场景下，校验盘压力大成为可靠性短板。</li>
<li><strong>典型应用场景</strong>：RAID 4 在纯读取密集场景下较 RAID 3 有优势，但其写入瓶颈令实际应用不广泛。历史上 NetApp 等厂商在自研文件系统中曾采用 RAID 4（因为他们有 NVRAM 等手段缓解写入瓶颈），但总体而言，RAID 4 已经被 RAID 5 所取代。现代系统很少直接配置 RAID 4，一般只在讨论 RAID 原理或少数遗留系统中提及。</li>
</ul>
<h3 id="RAID-5-–-分布式奇偶校验（Distributed-Parity）"><a href="#RAID-5-–-分布式奇偶校验（Distributed-Parity）" class="headerlink" title="RAID 5 – 分布式奇偶校验（Distributed Parity）"></a>RAID 5 – 分布式奇偶校验（Distributed Parity）</h3><p>RAID 5 是目前应用最广泛的 RAID 级别之一。它采用分布式奇偶校验技术，将数据条带和奇偶校验条带分布在阵列中所有磁盘上。简单说，在 RAID 5 中不存在固定的“校验盘”瓶颈，校验信息（Parity）和数据一起均匀地分布到每一块磁盘。每一条带（Stripe）内，有一块磁盘存储该条带的奇偶校验块，其余磁盘存储数据块，而且奇偶块的位置在各条带间循环轮换，使每块磁盘上既有数据又有部分条带的校验。这种设计避免了每次写入都集中更新同一磁盘的情况，从而消除了 RAID 4 中校验盘的性能瓶颈。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 5 至少需要 3 块磁盘。可用容量 &#x3D; (总磁盘数 - 1) × 最小单盘容量。换言之，相当于浪费了一块盘的容量用于存储分布在各盘的奇偶校验信息。例如 4 盘 RAID 5，可用容量约为 3 盘之和（75%利用率）；8 盘 RAID 5 则可用容量约为 7 盘之和（87.5%利用率）。各盘容量不同时按最小盘容量计算总容量。校验开销固定为一盘容量，因此随着磁盘数量增加，空间利用率越高（接近 100% 但永远少一盘容量）。</li>
<li><strong>性能特性</strong>：RAID 5 提供了均衡的读写性能和冗余保护，是一种兼顾存储性能与成本的折衷方案。<ul>
<li><strong>读取性能</strong>：因为数据条带分布在 (n-1) 块盘上（每条带有一盘是校验无实际数据），顺序读取时几乎相当于并行读取 (n-1) 块磁盘的数据，读取吞吐量接近 RAID 0（只比 RAID 0 少用了存储奇偶的那部分带宽）。随机读也能从不同盘并行获取数据，性能通常良好。</li>
<li><strong>写入性能</strong>：写入时由于需要更新奇偶校验，有一定开销。对一个数据块的写入，RAID 5 控制器通常需要读取相关条带上旧的数据和旧的校验块，计算出新的校验，然后写入新数据和新校验（称为“读 - 改 - 写”操作）。因此小块随机写入的 IOPS 性能相比单盘会有所下降。不过，对于大块顺序写入（如整条带写满），可以一次性计算整个条带的新校验并写入，效率较高。在有写缓存（如硬件 RAID 卡开启写回缓存）的情况下，RAID 5 的小写入性能也可显著改善。总体来说，RAID 5 的写性能略低于 RAID 0，但通常可达单盘性能的数十 % 以上，读性能接近 RAID 0 水平。</li>
</ul>
</li>
<li><strong>冗余与容错</strong>：可容忍 1 块磁盘故障。当阵列中某一盘失效时，其上的数据可由剩余所有数据块和对应的奇偶校验块计算重建。例如，对于任意一条带，如果其中一个数据块丢失，控制器会从该条带的其他数据块和奇偶块异或运算恢复丢失数据。阵列在单盘故障时仍可工作，但会进入“降级模式”：每次读取缺失盘的数据都需要动态计算（影响性能），写入也需更新额外校验。一般会尽快更换故障盘；新盘加入后，RAID 控制器会根据其余盘的数据和校验信息自动重建失去的数据到新盘上。重建期间磁盘负载很高，需要读取所有其余盘的数据，阵列性能会受影响且在此窗口如果再有第二块盘故障将导致数据不可恢复。</li>
<li><strong>优点</strong>：存储空间利用率高，冗余成本低（仅损失一盘容量就获得容错能力）；读取性能接近无冗余的条带化方案；能够容忍单盘失效，提供基本的数据安全保障；适用于多种应用，性价比突出。</li>
<li><strong>缺点</strong>：只允许单盘故障，若出现双盘同时故障则数据全部丢失；小随机写性能较差（有奇偶校验计算和读改写开销），不适合极高写入 IOPS 需求的场景；重建过程耗时且对存储系统是高压操作，大容量盘在 RAID 5 中重建可能需要数小时到数十小时，在此期间若再发生故障风险很高。</li>
<li><strong>典型应用场景</strong>：RAID 5 广泛用于需要平衡性能、容量和可靠性的场合。例如中小企业的文件服务器、数据库服务器（读多写少的负载）、虚拟化存储、备份存储等。许多 NAS 设备支持 RAID 5，也是家庭用户在有 3 块以上硬盘时经常选择的模式。在云服务和企业存储中，RAID 5 常用于对性能要求中等且希望节约成本的存储池。不过随着硬盘容量增大、重建时间增长，在要求更高可靠性的场景下，RAID 6 正逐渐取代 RAID 5 的位置。</li>
</ul>
<h3 id="RAID-6-–-双重奇偶校验（Double-Distributed-Parity）"><a href="#RAID-6-–-双重奇偶校验（Double-Distributed-Parity）" class="headerlink" title="RAID 6 – 双重奇偶校验（Double Distributed Parity）"></a>RAID 6 – 双重奇偶校验（Double Distributed Parity）</h3><p>RAID 6 进一步增强了 RAID 5，通过存储两套独立的奇偶校验信息来提供更高的数据保护能力。简单来说，RAID 6 在每个条带中有两个不同的校验块（例如常用 P+Q 双校验，其中 P 可以理解为类似 RAID 5 的异或校验，Q 为基于高级算法如里德 - 所罗门编码的第二校验）。这使得 RAID 6 即使同时有两块磁盘损坏，仍可利用剩余数据和两套校验信息完整恢复数据。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 6 至少需要 4 块磁盘。可用容量 &#x3D; (总磁盘数 - 2) × 最小单盘容量。也就是相当于有两块盘的容量用于存储校验信息（分布在所有盘上）。例如，6 盘 RAID 6 的可用容量为 4 盘之和（损失 2 盘容量用于冗余，利用率 ≈ 66.7%）；10 盘 RAID 6 则可用 8 盘容量（利用率 80%）。相较 RAID 5，RAID 6 增加了一份校验冗余，因此在相同磁盘数量下总可用空间略少。</li>
<li><strong>性能特性</strong>：RAID 6 的读取性能与 RAID 5 类似，读取时主要访问数据盘，两个校验盘位通常不参与正常读取（除非做数据校验或发生故障时重构），因此顺序读吞吐量约等于 <em>(n-2)</em> 块盘并行，接近 RAID 0 性能；随机读也能并行处理多个请求，性能良好。写入性能相对 RAID 5 进一步下降一些，因为每次写入需要计算和更新两种校验。写入一个数据块可能涉及读取旧数据及两份旧校验、计算两份新校验，再写入新数据和新校验共三个盘的写操作（被称为“读 - 改 - 写”开销）。因此 RAID 6 的小块写入有更高的 I&#x2F;O 和计算开销（写入代价比 RAID 5 更大）。在没有硬件加速的情况下，RAID 6 的写性能对 CPU 和总线负荷要求更高，通常更适合由硬件 RAID 卡实现。如果有高效的 RAID 卡或启用写缓存，RAID 6 的写性能可被优化到接近 RAID 5 水平。</li>
<li><strong>冗余与容错</strong>：可容忍任意两块磁盘同时故障。这是 RAID 6 最大的优势。当一块盘损坏时，RAID 6 与 RAID 5 类似，可通过剩余数据 + 两校验之中的一份来重建数据；当在重建尚未完成期间又有第二块盘损坏，剩余的数据加两份校验仍然足以恢复这两块损坏盘的数据。只有当同时超过两块磁盘损坏（例如第三块盘在前两块未恢复前损坏）时，阵列才会崩溃丢失数据。RAID 6 大大降低了在大容量阵列中重建过程中再次发生盘损坏而导致数据彻底丢失的风险。更换坏盘后，系统会利用剩余盘上的数据和双校验重新计算并写入新盘，重建过程较 RAID 5 更耗时一些（因为计算更复杂、写入更多）。但总体重建流程与 RAID 5 类似，只是需要处理两套校验。</li>
<li><strong>优点</strong>：提供比 RAID 5 更高的安全性，可耐受双盘失效，适合对数据可靠性要求高的应用；读取性能依然接近 RAID 0；容量利用率在阵列较大时依然可观（例如 10 盘阵列有 80% 容量可用，比镜像方案效率高得多）。</li>
<li><strong>缺点</strong>：实现和计算复杂度更高，小写入性能较弱（双校验更新带来更大写入惩罚）；需要至少 4 盘起步，灵活性略差；重建时间更长。同时，RAID 6 对硬件要求较高，一般需要专用 RAID 卡或强大的 CPU 来避免性能瓶颈。</li>
<li><strong>典型应用场景</strong>：RAID 6 常用于中大型存储阵列中，特别适合需要大容量且强调高可靠性的场景，如企业级存储系统、文件服务器、备份和归档系统、大型 NAS&#x2F;SAN 阵列等。当单阵列中磁盘数量较多或使用了大容量磁盘时，RAID 6 是比 RAID 5 更安全的选择，因为双盘失效的概率在长时间重建中不可忽视。许多硬件 RAID 控制器广泛支持 RAID 6，现代存储方案（如分布式存储里的数据保护）也借鉴了双冗余校验的思想。</li>
</ul>
<h3 id="RAID-0-1-（RAID-01）–-先条带后镜像的组合"><a href="#RAID-0-1-（RAID-01）–-先条带后镜像的组合" class="headerlink" title="RAID 0+1 （RAID 01）– 先条带后镜像的组合"></a>RAID 0+1 （RAID 01）– 先条带后镜像的组合</h3><p>RAID 0+1（常称 RAID 01）是 RAID 0 和 RAID 1 的嵌套组合，实现上先进行条带化（RAID 0），再对条带化结果做镜像（RAID 1）。假设有 6 块盘构成 RAID 01，首先将数据在 3 块盘上条带存储（RAID 0 获得高性能和容量），然后使用另外 3 块盘镜像这 3 块数据盘（提供冗余）。换言之，RAID 01 把所有磁盘分成两组，各自先做 RAID 0，然后两组之间再做 RAID 1 作为镜像副本。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 01 的可用容量等于阵列中一半磁盘容量之和（因为另一半用于镜像）。比如 6 盘 RAID 01，由于一半做条带数据盘，一半做镜像盘，可用容量为 3 盘容量总和（利用率 50%）。总体容量利用率与 RAID 10 类似，均是 50%（当使用对称分组时）。</li>
<li><strong>性能特性</strong>：RAID 01 正常情况下的性能与 RAID 0+RAID 1 类似：读取可以利用镜像的并行，理论上有一定提升；写入需要将条带化的数据写到两个镜像组中，写性能略低于同等 RAID 0，但仍保持较高水平。顺序读写性能基本接近 RAID 0，随机读在多线程场景下可有所提升，随机写由于镜像需要双写入，性能与 RAID 10 相近。总的来说，RAID 01 在无故障时性能与 RAID 10 相差不大，属于高性能阵列。</li>
<li><strong>冗余与容错</strong>：可容忍至少一块磁盘故障，但容错机制较微妙：当 RAID 01 中一块磁盘损坏时，该盘所在的 RAID 0 组整体失效，因为 RAID 0 无冗余。此时整个阵列退化为另一组 RAID 0（即只有镜像的另一半还在）。举例来说，6 盘 RAID 01（两组 RAID 0，每组 3 盘）中，任意一盘坏，会导致该盘所在的整个 RAID 0 组的数据不可用，相当于一下损失了该组的 3 盘数据，但由于有镜像，另一 3 盘组还有一份完整的数据，可继续提供服务。然而在这种情况下，阵列变为无冗余状态（只剩下一个 RAID 0 在运行）。如果再损坏任何一块盘（不论在哪组，因为一组已经全失效，另一组任何盘坏都直接令阵列崩溃），则阵列数据彻底丢失。因此 RAID 01 在第一次故障后变得非常脆弱，只能容忍任意一组中的单盘故障。如果恰巧第一组有盘坏了，第二组绝不能再坏。总故障容忍度等价于只能承受一次单组故障。</li>
<li><strong>优点</strong>：在无故障时提供了与 RAID 10 接近的高性能和高吞吐量；实现和理解相对简单（就是 0 和 1 两级嵌套）。</li>
<li><strong>缺点</strong>：容错能力较差，相比 RAID 10 更容易在多盘故障时失效。一次故障后整个阵列立即降为 RAID 0 状态，失去冗余保护；磁盘利用率低（50%）；需要较多磁盘数（至少 4 个）才能实现。</li>
<li><strong>典型应用场景</strong>：由于 RAID 01 在故障后的安全性不佳，实际应用中很少直接采用 RAID 0+1。一般只有在某些对性能要求极高且已另有备份的数据场景下才可能使用（例如将两个已有 RAID 0 卷做镜像以提高可用性），但更多情况下人们会选择 RAID 10 作为替代，因为 RAID 10 提供更好的容错。总的来说，RAID 01 作为理论存在多于实践应用。</li>
</ul>
<h3 id="RAID-1-0-（RAID-10）-–-先镜像后条带的组合"><a href="#RAID-1-0-（RAID-10）-–-先镜像后条带的组合" class="headerlink" title="RAID 1+0 （RAID 10） – 先镜像后条带的组合"></a>RAID 1+0 （RAID 10） – 先镜像后条带的组合</h3><p>RAID 10（又称 RAID 1+0）是最常用的嵌套 RAID 之一，它通过先做镜像、再做条带的方式，将 RAID 1 和 RAID 0 的优势结合在一起。实现上，RAID 10 先将所有磁盘两两组成镜像对（RAID 1 提供冗余），然后再将这些镜像对作为独立“盘”条带化（RAID 0 提供性能和容量）。例如，有 4 块盘时，RAID 10 会先组成两个镜像（每对 2 盘），再将两个镜像组合成条带；8 块盘则组成 4 对镜像，再 4 组做条带，以此类推。RAID 10 常被誉为“两全其美”的方案，具有 RAID 0 的高速性能和 RAID 1 的镜像安全性。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 10 的可用容量约为阵列中一半磁盘容量总和。同 RAID 01 一样，每两块盘做镜像，只能使用其中一盘容量；镜像对数量为磁盘数的一半，然后所有镜像对再条带，总容量 &#x3D; 镜像对数 × 单对容量。简而言之，利用率 50%（偶数盘情况下）。例如 8 盘 RAID 10，可用容量等于 4 盘容量之和（其余 4 盘用于镜像冗余）。</li>
<li><strong>性能特性</strong>：RAID 10 在性能方面表现优异且稳定。因为数据在每对镜像中有两份，读取时控制器可以智能地从中选择更快的一份读取，或者并行读不同镜像以提高总吞吐。顺序读取 &#x2F; 写入性能接近 RAID 0 条带化的水平（使用一半数量的盘，因为另一半是镜像冗余）。例如 8 盘 RAID 10 的顺序吞吐量大致相当于 4 盘 RAID 0，因为 8 盘组成 4 个镜像对再条带。随机读取性能尤其突出：多个镜像可以同时处理不同的读请求，随机读 IOPS 在多线程情况下远超单盘。写入性能则与镜像类似：每对镜像内部需要写入两份，但这些镜像对之间是并行条带的关系，所以整体写入吞吐仍可接近多盘并行。对比 RAID 5&#x2F;6，RAID 10 的写入没有奇偶校验开销，随机写性能明显更好，延迟更低，非常适合高 I&#x2F;O 应用。</li>
<li><strong>冗余与容错</strong>：RAID 10 具有较高的容错能力和可靠性。它能容忍的故障数取决于故障分布：只要不是同一镜像对的两盘都坏，阵列就能保持数据完整。具体来说，每个镜像对可以容忍 1 盘故障。如果不同镜像对各损坏一盘，RAID 10 仍能正常运行；理论上对于有 m 对镜像的 RAID 10，最理想情况下可容忍 m 块盘分别在不同对中损坏（每对坏 1 盘）而不丢失数据。不过，如果某一镜像对两盘全部故障，那组数据无副本可用，整个阵列即失效。因此最坏情况下 RAID 10 只能容忍与 RAID 1 相同的 1 对盘故障（镜像对内双盘坏则崩溃）。但相比 RAID 01，RAID 10 在第一次故障后的安全性更高：假设 8 盘 RAID 10 有 1 盘故障，则仅影响该镜像对，其他镜像对不受牵连，阵列仍以 RAID 1 模式保护剩余数据。除非同一对的第二盘在重建完成前故障，否则数据仍然安全。这种故障模式显著优于 RAID 0+1。在替换掉故障盘后，控制器会将其镜像对的另一盘数据拷贝到新盘进行重建，恢复成完整镜像。重建期间只需要读取该对中完好盘即可，速度较快且对其它盘无额外压力。</li>
<li><strong>优点</strong>：兼具高性能和高可靠性：读写速度接近 RAID 0，故障耐受接近 RAID 1；无奇偶校验计算，延迟低；在多盘阵列中仍有弹性的容错能力（非同组故障不丢数据）；重建快速。</li>
<li><strong>缺点</strong>：存储利用率低（50%）；磁盘数量要求至少 4 个，扩展成本高；相比单纯 RAID 5&#x2F;6，容量开销较大（适合磁盘容量充裕情况下使用）。</li>
<li><strong>典型应用场景</strong>：RAID 10 非常适合需要高速随机读写且要求高可用性的场景。例如 OLTP 数据库、大型事务系统、虚拟化环境（VM 存储）、高负载邮件服务器等。这些场景下 RAID 5&#x2F;6 的写入性能可能无法满足要求，而 RAID 10 提供了出色的 I&#x2F;O 性能和冗余保障。很多企业级数据库和 I&#x2F;O 密集应用推荐使用 RAID 10。由于其优秀的性能和冗余，RAID 10 也被用于一些中高端 NAS&#x2F;SAN 中以支撑关键业务。</li>
</ul>
<h3 id="RAID-50-–-条带化的-RAID-5-组合"><a href="#RAID-50-–-条带化的-RAID-5-组合" class="headerlink" title="RAID 50 – 条带化的 RAID 5 组合"></a>RAID 50 – 条带化的 RAID 5 组合</h3><p>RAID 50（有时称为 RAID 5+0）是将多个 RAID 5 阵列再做条带化的组合级别。实现方式通常是先将磁盘分成若干组，每组独立组成 RAID 5 阵列，再将这些 RAID 5 组按照 RAID 0 方式跨区条带。例如，最小的 RAID 50 可以用 6 块盘构成：先分成两组各 3 盘做 RAID 5（每组有 1 盘作为奇偶校验），得到两个 RAID 5 逻辑盘；然后再对这两个逻辑盘做条带（RAID 0）。这样的结构同时利用了 RAID 5 的冗余和 RAID 0 的性能拓展。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 50 的可用容量取决于子阵列个数和每组大小。一般公式为：可用容量 &#x3D; 总磁盘数 - 每组 RAID5 的组数（因为每组浪费一块做校验）。如果总盘数为 N，分成 g 组，则每组大小 k &#x3D; N&#x2F;g，每组有效盘数 (k-1)，总有效盘数 &#x3D; g(k-1) &#x3D; N - g。例如上述 6 盘例子：分 2 组 RAID5，每组 3 盘（有效 2 盘），两组总有效盘 4，容量利用率 &#x3D; 4&#x2F;6 ≈ 66.7%。再如 9 块盘如果做 RAID 50，可以分 3 组每组 3 盘 RAID5，则可用容量 &#x3D; 9 - 3 &#x3D; 6 盘容量（利用率 ≈ 66.7%）；若分成 2 组一组 5 盘一组 4 盘则不太均衡，一般会尽量平均分组。与单组 RAID 5 相比，RAID 50 由于每组都有奇偶开销，总的冗余开销略高。例如 9 盘单 RAID5 利用率约 88.9%，而 3 组 3 盘 RAID50 利用率只有 66.7%。但更常见的是在有很多盘时考虑 RAID 50，以避免单一 RAID 5 组过大导致重建风险增高。</li>
<li><strong>性能特性</strong>：RAID 50 将 RAID 5 阵列进行条带化，提高了并行 I&#x2F;O 性能。<ul>
<li><strong>读取性能</strong>：多个 RAID 5 组并行提供数据，顺序读写可以从多个组同时进行，理论吞吐比单 RAID 5 高。同时各组内部又有条带，随机读可同时访问不同组，提高并发能力。</li>
<li><strong>写入性能</strong>：RAID 50 的小写入性能仍然受限于 RAID 5 的“读改写”机制，每组内部写入需要计算奇偶校验，但因为存在多个组，并发写入可以分散到不同组，缓解了单一 RAID5 在高并发写入时的瓶颈。总体来说，RAID 50 的顺序吞吐量和 IOPS 均高于单一 RAID 5 阵列，接近 RAID 0 等级；但在单一写入线程情况下，其写性能仍需执行 RAID5 校验计算，不如 RAID 0&#x2F;10。</li>
</ul>
</li>
<li><strong>冗余与容错</strong>：RAID 50 可以看作提供一定多盘容错能力：每个子阵列 RAID 5 可容忍 1 盘故障，因此只要每个子阵列故障盘不超过 1 个，RAID 50 整体数据不丢失。例如 2 组 RAID5，即使每组各坏 1 盘（总坏 2 盘），阵列仍然可用。但如果任意一组中有 2 盘失效（超出 RAID5 冗余能力），则该组数据不可恢复，继而整个 RAID 50 失效。因此 RAID 50 的实际容错取决于故障分布：不同组可以各坏一盘而无事，但如果多盘故障落在同一组就危险。相较单一大 RAID 5 组只能容忍 1 盘失效，RAID 50 在理想情况下容忍度提升（比如 4 组 RAID5 理论可容忍 4 盘各在不同组故障）；但是容忍的前提是故障分散。重建过程也是分组进行：某盘故障仅需要其所在 RAID5 组进行校验重建，其余组不受影响。这意味着重建压力可以隔离在较小范围内，降低对整个阵列性能的冲击。</li>
<li><strong>优点</strong>：相比单一大型 RAID 5，RAID 50 在性能和可靠性上都有提升：并行条带提高吞吐，并发重建降低风险；可一定程度容忍多盘故障（各组各 1 盘）；重建时间缩短（每组独立重建更快）。</li>
<li><strong>缺点</strong>：有效容量比同等磁盘数做 RAID 5 更低（因为多个组多次损失校验盘容量）；实现结构更复杂，配置不当可能导致容量浪费（需要均衡分组）；仍无法容忍单组内的双盘失效；相比 RAID 10，RAID 50 在双盘不同组故障下虽然还能运行，但数据安全性不如双镜像可靠。</li>
<li><strong>典型应用场景</strong>：RAID 50 适用于具有大量磁盘的存储系统，希望在 RAID 5 的空间效率基础上增强性能和可靠性。例如一些大容量的盘柜 &#x2F; 磁盘阵列，可能有 20 块盘以上，为降低单组 RAID 5 重建风险和提升性能，可以考虑将其分成 2 或更多组 RAID5 再条带。常见用于数据仓库、大型 NAS 设备、视频监控存储等需要高顺序吞吐且容量较大的场景，也有用于某些服务器的本地存储。当磁盘数量较多时，与其做一个 RAID 5，不如拆分为多个 RAID5 做 RAID50 会是更好的折中。</li>
</ul>
<h3 id="RAID-60-–-条带化的-RAID-6-组合"><a href="#RAID-60-–-条带化的-RAID-6-组合" class="headerlink" title="RAID 60 – 条带化的 RAID 6 组合"></a>RAID 60 – 条带化的 RAID 6 组合</h3><p>RAID 60（RAID 6+0）与 RAID 50 类似，是将多个 RAID 6 阵列条带化后的组合级别。实现上，先将磁盘分成若干组，各组做 RAID 6（具有双奇偶校验容错），再将这些组作为独立单元进行 RAID 0 条带。例如，8 块盘可做成两个 4 盘 RAID 6 组，然后两组条带化得到 RAID 60；典型配置常用更多盘，例如 16 盘可分成两组 8 盘 RAID6 或 4 组 4 盘 RAID6，再条带化。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID 60 至少需要8 块盘（因为每组 RAID6 最少 4 盘，两组起条带）。可用容量 &#x3D; 总盘数 - 2×(组数)。即每组有 2 盘容量用于校验，总的校验盘开销是 2×组数。例如，8 盘分两组 4 盘 RAID6，可用容量 &#x3D; 8 - 2×2 &#x3D; 4 盘容量（利用率 50%）；16 盘分两组 8 盘，则可用容量 &#x3D; 16 - 2×2 &#x3D; 12 盘容量（利用率 75%）；如果 16 盘分 4 组 4 盘，则可用容量 &#x3D; 16 - 2×4 &#x3D; 8 盘容量（利用率 50%）。由此可见 RAID 60 的容量利用率取决于每组大小，组越大利用率越高，但过大组会牺牲可靠性优势。</li>
<li><strong>性能特性</strong>：RAID 60 具有优异的顺序吞吐性能。多组 RAID 6 并行条带，顺序读写可以同时从多个组获取数据，带宽比单一 RAID 6 更高。每组内部有双校验，单组顺序性能略逊于 RAID 5，但多个组并行可以弥补甚至超越单组性能。随机性能方面，读取并发性和 RAID 50 类似，多组可同时服务多个请求；写入性能受 RAID 6 双校验影响，每组内部小写的开销较大，但并行组仍有助于提高总 IOPS。在重负载下，RAID 60 比单一 RAID 6 能提供更好的性能扩展，因为 I&#x2F;O 压力分摊到多个子阵列上。</li>
<li><strong>冗余与容错</strong>：RAID 60 可以容忍每个子阵列中最多 2 块磁盘故障。因此只要每组损坏盘数 ≤2，整个阵列数据保持完好。例如 2 组 RAID6 的 RAID 60，即使总共坏到 4 块盘（每组各 2 块），仍然不丢失数据。但如果任一组中出现第 3 块磁盘故障，该组将崩溃，从而导致整个阵列失效。这种情况发生的概率极低，但要注意 RAID 60 虽然提高了可靠性，仍非无限安全。同样地，多盘故障的影响取决于分布：RAID 60 能承受多块盘同时失效，只要不超过两盘落在同一组内。相比单一大型 RAID 6 阵列只能抗 2 盘坏，RAID 60 在一定程度上降低了多盘连续故障导致数据丢失的风险。重建时，每个故障盘在其所属的小组内进行双奇偶校验恢复，其余组不受牵连，这比在一个超大 RAID6 中重建要更快也更安全（重建并行且数据划分在更小组里）。</li>
<li><strong>优点</strong>：非常高的容错能力，可耐受多盘故障（各组可各坏 2 盘）；读取性能极佳，多组并行读写提升吞吐；相比超大 RAID6，重建压力分散，重建速度加快，总体可靠性提升。</li>
<li><strong>缺点</strong>：可用容量比单一 RAID6 稍低（多个组有多份校验开销）；实现复杂，配置需要合理规划组大小和平衡；小写入性能依然受限于双重校验开销；需要较多磁盘起步（通常只有在磁盘数量很多时才考虑 RAID 60）。</li>
<li><strong>典型应用场景</strong>：RAID 60 多见于超大容量存储服务器或盘阵中，比如动辄几十块盘的大型 SAN&#x2F;NAS。当单个 RAID6 包含过多磁盘时，重建时间漫长且双盘故障风险增加，采用 RAID 60 分组能缓解这些问题。典型应用如不方便频繁备份的大型视频监控存储、海量数据归档、高性能计算集群存储等，这些场景需要既防止多盘故障又兼顾性能。总之，在拥有非常多硬盘并要求极高数据冗余的情况下，RAID 60 是比 RAID 50 更安全的方案，但其复杂性和容量代价也更高。</li>
</ul>
<h3 id="JBOD-–-独立磁盘-并列盘组-Just-a-Bunch-of-Disks"><a href="#JBOD-–-独立磁盘-并列盘组-Just-a-Bunch-of-Disks" class="headerlink" title="JBOD – 独立磁盘 &#x2F; 并列盘组 (Just a Bunch of Disks)"></a>JBOD – 独立磁盘 &#x2F; 并列盘组 (Just a Bunch of Disks)</h3><p>JBOD 并非严格的 RAID 级别，而是一个术语，意思是“一堆磁盘”（Just a Bunch of Disks）。JBOD 通常指两种情况之一：其一是多个磁盘独立存在，不做任何 RAID 或逻辑组合，每块磁盘各自作为单独卷使用；其二是将多个物理磁盘的空间简单相加合并成一个大逻辑卷（有时称为 Span 或 Concatenation 模式）。后者在某些操作系统 &#x2F; 控制器中也被称为 JBOD 模式，即把多块磁盘顺序拼接成一个虚拟盘，以增加单一卷的容量。</p>
<ul>
<li><strong>空间计算方式</strong>：如果是独立磁盘模式，每块盘容量不变，总容量为各盘容量总和，但分别呈现为多个卷；如果是拼接模式，所有盘容量简单累加呈现为一个卷。因此 JBOD 模式没有冗余开销，可用空间等于磁盘容量总和（拼接时需要所有盘尺寸相加）。需要注意拼接卷的单一文件系统跨越多盘，一旦其中一盘故障，该卷的数据完整性受到破坏。</li>
<li><strong>性能特性</strong>：JBOD（独立盘）不提供任何性能聚合，每块磁盘性能独立；在拼接模式下，数据顺序写满第 1 盘再写第 2 盘，以此类推。因此对于顺序 I&#x2F;O，当写满前一盘转移到下一盘时，可能出现短暂延迟，总体性能基本与单盘相当。没有并行条带，也无校验计算，IOPS 和吞吐不会超出单盘范围（除非多个独立盘并行服务不同请求，那只是因为操作系统看到多卷并调度它们并行）。换句话说，JBOD 不提升性能，也不会像 RAID 那样有写入惩罚或校验开销。它的性能特征近似于 RAID 0 在没有并行优势的情况下：没有冗余也没有性能优化。</li>
<li><strong>冗余与容错</strong>：JBOD 不提供冗余。独立磁盘场景下，每块盘故障只影响该盘的数据，其它盘不受影响（因为没有关联）；拼接卷场景下，任意一盘故障都会导致整个逻辑卷的数据不完整（卷将损坏，位于故障盘之后的数据全部丢失）。因此 JBOD（拼接模式）的故障域和 RAID 0 相当：一盘坏则整个卷不可用。数据恢复只能针对单盘进行（独立模式）或尝试部分恢复（拼接模式通常难以恢复完整卷，只能根据备份还原）。</li>
<li><strong>优点</strong>：实现简单，无需专门 RAID 控制；容量利用率 100% 没有损失；可以混合不同大小的磁盘拼接利用每一字节空间；对于一些不需要性能提升且更关注容量利用的场合，是种灵活选择。独立盘方式下某盘故障不影响其他盘的数据。</li>
<li><strong>缺点</strong>：无任何冗余保护，可靠性低；拼接后的卷一盘损坏可能导致整个卷文件系统崩溃；不提供性能提升；管理上多个独立盘缺乏整合，或者拼接盘对故障非常敏感。</li>
<li><strong>典型应用场景</strong>：JBOD 常用于临时性或非关键数据存储，以及需要将若干杂余硬盘容量汇聚起来的情况。例如个人用户将数块旧硬盘拼成一个大卷来存放媒体文件、下载文件等非重要数据；或者一些简单备份，把不同数据分别存储在不同独立磁盘上。许多 NAS 设备提供 JBOD 模式供用户在不需要 RAID 时使用全部容量。但总的来说，JBOD 由于缺乏冗余，在任何重要场景下都应谨慎对待，确保有额外的数据备份。</li>
</ul>
<h3 id="RAID-DP-–-双奇偶校验的专有实现-NetApp-RAID-DP"><a href="#RAID-DP-–-双奇偶校验的专有实现-NetApp-RAID-DP" class="headerlink" title="RAID-DP – 双奇偶校验的专有实现 (NetApp RAID-DP)"></a>RAID-DP – 双奇偶校验的专有实现 (NetApp RAID-DP)</h3><p>RAID-DP（Double Parity RAID）是存储厂商 NetApp 引入的一种专有 RAID 实现，可视为 RAID 6 的一种变体。RAID-DP 使用了双重奇偶校验机制来提供更高的数据保护能力，能够在两块磁盘同时失效的情况下仍然保证数据完好。与标准 RAID 6 类似，RAID-DP 在每个 RAID 组中指定了两块盘作为奇偶校验盘，用来存储两种不同算法计算的校验信息。不同之处在于，NetApp 的 RAID-DP 基于其 WAFL 文件系统和 RAID4 架构做了优化，使性能损失较小。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID-DP 每个阵列组拥有两块专用奇偶校验盘。可用容量 &#x3D; (总盘数 - 2) × 单盘容量，和 RAID 6 相同的计算方法。如果一个 NetApp 聚合（aggregate）使用 RAID-DP，例如有 10 块盘，则其中 2 盘为奇偶校验，8 盘用于数据（利用率 80%）。NetApp 通常建议 RAID-DP 组大小在一定范围内（如 12～20 个 HDD 为一组），以平衡奇偶开销和重建时间。</li>
<li><strong>性能特性</strong>：NetApp 宣称 RAID-DP 的性能与 RAID 10 相近，在多数情况下并不会比 RAID 4&#x2F;RAID 5 有明显下降。这是因为 NetApp 的实现利用 NVRAM 等机制，优化了写入路径，避免了传统 RAID 6 那种每次更新需要大量同步 IO 的问题。在实际应用中，RAID-DP 的顺序读写性能与 RAID 4 接近（因为本质架构仍是类似 RAID4，只是多一个校验盘）；随机写由于双校验，需要略多计算，但 NetApp 通过并行和缓存将其影响降到极小。总体而言，在 NetApp 存储系统上，启用 RAID-DP 不会对性能造成显著瓶颈，同时显著提高了容错能力。</li>
<li><strong>冗余与容错</strong>：RAID-DP 能容忍同时两盘失效而数据不丢失。这一点与 RAID 6 一致。在 NetApp 系统中，RAID-DP 已成为默认 RAID 类型。当一盘损坏时，利用剩余数据 + 2 校验可恢复；两盘损坏亦可通过剩余盘和校验重建两盘数据。只有当超过两盘同时损坏或在重建过程中又发生第三盘故障，数据才会不可恢复。NetApp 的 RAID-DP 还配合了热备盘（Hot Spare）和预防性故障检测等策略，进一步降低了阵列崩溃概率。</li>
<li><strong>优点</strong>：提供接近 RAID 10 的性能以及远高于 RAID 5 的可靠性（双盘冗余），在企业存储环境中非常实用；相比镜像冗余，存储效率高得多（仅 2 盘冗余开销可保护大量数据盘）；NetApp 实现有许多优化使得重建快速且对业务影响小。对于需要高可靠性又要兼顾容量利用的场景，RAID-DP 是一个理想选择。</li>
<li><strong>缺点</strong>：作为 NetApp 的专有技术，RAID-DP 并非所有平台都支持；其理念类似 RAID 6，因此如果脱离 NetApp 环境，软件实现 RAID-DP 的性能会有与一般 RAID 6 相似的开销；只能由特定存储系统使用，灵活性不如通用 RAID 方案。</li>
<li><strong>典型应用场景</strong>：RAID-DP 几乎应用于所有 NetApp ONTAP 存储系统中，从中端的 FAS 阵列到高端存储，都默认采用 RAID-DP 来构建底层 RAID 群组，以保护企业数据安全。适合需要极高可用性且使用 NetApp 方案的场景，比如大型企业文件存储、虚拟化环境、数据库存储等。在 NetApp 之外，一般用“RAID6”实现类似功能；但 NetApp RAID-DP 的成功也影响了业界对双奇偶校验 RAID 的接受度，如今双校验已成为企业级存储的标准配置之一。</li>
</ul>
<h3 id="RAID-Z-–-动态条带的-ZFS-RAID-实现"><a href="#RAID-Z-–-动态条带的-ZFS-RAID-实现" class="headerlink" title="RAID-Z – 动态条带的 ZFS RAID 实现"></a>RAID-Z – 动态条带的 ZFS RAID 实现</h3><p>RAID-Z 是开源 ZFS 文件系统中特有的冗余磁盘阵列实现，可以看作对应于传统 RAID 5&#x2F;6 的新型变种。RAID-Z 的设计目标是在提供奇偶校验冗余的同时消除 RAID 5 的“写入漏洞”问题。ZFS 结合文件系统和设备管理，将写入操作整合成事务，每次写入时动态决定条带宽度，使所有写入都是全条带写入。因此不会出现传统 RAID 在未写满一个条带时更新奇偶校验可能导致的不一致问题（即 RAID-5 Write Hole）。</p>
<p>RAID-Z 根据冗余程度不同分为三级：RAID-Z1（单奇偶校验，相当于 RAID5）、RAID-Z2（双奇偶校验，相当于 RAID6）、RAID-Z3（三奇偶校验）。</p>
<ul>
<li><strong>空间计算方式</strong>：RAID-Z1&#x2F;Z2&#x2F;Z3 的可用容量类似于 RAID5&#x2F;6 逻辑：分别损失 1、2、3 块盘空间用于冗余校验。例如，6 盘 RAID-Z2 可用容量约等于 4 盘总和（损失 2 盘容量）；10 盘 RAID-Z3 可用容量约等于 7 盘总和（损失 3 盘容量）。ZFS 要求一个 RAID-Z vdev（类似于 RAID 组）的所有成员盘大小最好一致，否则会浪费额外空间填充对齐。在容量计算上，ZFS 还允许动态扩展（RAID-Z Expansion 功能，未来可以通过增加盘来扩容阵列）。</li>
<li><strong>性能特性</strong>：RAID-Z 的读取性能与传统 RAID 5&#x2F;6 类似，在单块盘发生故障前，读取通常只访问数据盘，不需额外计算；顺序读取多个盘并行，性能接近条带化阵列。写入性能方面，由于 RAID-Z 确保每次写入都是完整条带写入（通过收集足够数据或填充来避免部分条带更新），因此避免了小写入反复读改写校验的开销。这使 RAID-Z 在应对随机同步写入时比传统 RAID 5 有更好的性能和一致性。同时 ZFS 的 ARC 缓存和写日志（ZIL）也提高了写入效率。总体来说，RAID-Z 的性能相对于 RAID 5&#x2F;6 有所改进，尤其在崩溃后无需担心数据和奇偶不一致，可直接继续工作或回滚事务，可靠性和性能稳定性更佳。</li>
<li><strong>冗余与容错</strong>：RAID-Z1 可容忍 1 盘故障，RAID-Z2 可容忍 2 盘故障，RAID-Z3 则可容忍 3 盘同时故障。这对应于各自奇偶校验的数量。发生故障盘时，ZFS 会利用奇偶数据和其他盘数据在线重建丢失的数据块到热备盘或新盘。在重建过程中，RAID-Z 依靠 ZFS 的校验和机制，可以确保读取出的数据正确性（ZFS 每个块都有校验和，能发现数据损坏）。如果再有盘损坏超过冗余能力，则该 vdev 崩溃，涉及那个 vdev 的数据池部分不可用。不过 ZFS 通常可以由多个 vdev 组成池，单个 vdev 挂掉相当于池的一部分数据丢失，整个池也就失效了。</li>
<li><strong>优点</strong>：消除了 RAID-5 经典问题（写入漏洞），数据一致性更有保障；深度集成文件系统的优势，支持数据自校验、自动修复；提供从 1 到 3 盘的冗余选择，灵活性比传统 RAID 高；写入性能针对小 IO 有所优化；还能在线扩展阵列容量（新版本 ZFS 支持 RAID-Z 逐盘增加扩容）。</li>
<li><strong>缺点</strong>：RAID-Z 对内存要求较高（ZFS 整体设计需要大量内存做缓存）；只支持在 ZFS 文件系统环境中使用，不像硬件 RAID 那样通用；当前 RAID-Z 扩容限制较多（需要一次性增加整组盘才能扩容，直到最近的新特性才允许逐个增加盘位）；ZFS 管理和调优有一定学习成本。</li>
<li><strong>典型应用场景</strong>：RAID-Z 广泛用于开源 NAS 和数据存储领域，例如 FreeNAS&#x2F;TrueNAS 等 ZFS 系统中。个人和企业用户利用 ZFS 的先进特性（快照、压缩、数据完整性）来构建可靠存储，RAID-Z 为其提供了类似 RAID 的冗余保护。常见场景包括家用 NAS、大容量备份服务器、虚拟机数据存储、容器平台持久化存储等，特别是对数据完整性要求高的地方。RAID-Z2 是很多 NAS 配置中的推荐方案，因为它在容量和安全性上平衡较好；RAID-Z3 则用于需要极高安全性的环境（比如大型存储阵列防止三盘故障）。总的来说，如果采用 ZFS，RAID-Z 系列是首选的冗余方案。</li>
</ul>
<h2 id="各-RAID-级别特性对比"><a href="#各-RAID-级别特性对比" class="headerlink" title="各 RAID 级别特性对比"></a>各 RAID 级别特性对比</h2><p>下面的表格总结了主要 RAID 级别的关键特性，包括所需最少磁盘数、最大容错（可容忍的同时故障磁盘数）、可用容量计算、以及相对的读写性能表现和典型应用场景，便于对比不同方案：</p>
<table>
<thead>
<tr>
<th>RAID 级别</th>
<th>最少硬盘数</th>
<th>最大容错 (故障盘)</th>
<th>可用容量 (以单盘容量 S 计)</th>
<th>读性能 (顺序 &#x2F; 并发)</th>
<th>写性能 (顺序 &#x2F; 随机)</th>
<th>典型应用场景及特点</th>
</tr>
</thead>
<tbody><tr>
<td>JBOD</td>
<td>1</td>
<td>0（无冗余）</td>
<td>n × S（所有盘之和）</td>
<td>≈ 单盘 (无并行提升)</td>
<td>≈ 单盘 (无校验开销)</td>
<td>非关键数据的容量汇聚，个人临时存储。无性能增益，故障风险同 RAID0。</td>
</tr>
<tr>
<td>RAID 0</td>
<td>2</td>
<td>0（无冗余）</td>
<td>n × S</td>
<td>n × 单盘（顺序）</td>
<td>n × 单盘（顺序）</td>
<td>并发读 &#x3D; n，随机写 ≈ 单盘。追求最大性能和容量的场景，如视频编辑临时盘、高速缓存等。不怕数据丢失。</td>
</tr>
<tr>
<td>RAID 1</td>
<td>2</td>
<td>n-1（镜像盘数 - 1）</td>
<td>1 × S（与最小盘相同）</td>
<td>≤n × 单盘（读可并行）</td>
<td>1 × 单盘（需写入镜像）</td>
<td>最高数据安全性；个人 &#x2F; 企业重要数据、系统盘。磁盘利用率低。</td>
</tr>
<tr>
<td>RAID 2</td>
<td>3</td>
<td>1</td>
<td>(≈ n - 多个校验盘) × S</td>
<td>所有盘并行 (需同步)</td>
<td>所有盘并行 (高 ECC 开销)</td>
<td>理论级别，采用 ECC 汉明码。实际很少实现，了解概念为主。</td>
</tr>
<tr>
<td>RAID 3</td>
<td>3</td>
<td>1</td>
<td>(n - 1) × S</td>
<td>高 – 多盘并行顺序读</td>
<td>低 – 小随机需要全盘</td>
<td>中 – 顺序写并行，低 – 校验盘瓶颈</td>
</tr>
<tr>
<td>RAID 4</td>
<td>3</td>
<td>1</td>
<td>(n - 1) × S</td>
<td>中高 – 并行读不同盘</td>
<td>中等 – 写受限于校验盘</td>
<td>很少单独使用，曾用于特定存储系统。性能介于 RAID3 和 5 之间。</td>
</tr>
<tr>
<td>RAID 5</td>
<td>3</td>
<td>1</td>
<td>(n - 1) × S</td>
<td>高 – 近似 <em>(n-1)</em> 倍读</td>
<td>中等 – 顺序写接近 <em>(n-1)</em> 倍，随机写有校验开销</td>
<td>常用折衷方案，兼顾性能、容量和安全；个人和小型企业存储常用。</td>
</tr>
<tr>
<td>RAID 6</td>
<td>4</td>
<td>2</td>
<td>(n - 2) × S</td>
<td>高 – 近似 <em>(n-2)</em> 倍读</td>
<td>中下 – 写入有双校验较大开销</td>
<td>双冗余保障，高可靠企业存储常用。适合大容量、多盘环境，读多写少负载。</td>
</tr>
<tr>
<td>RAID 0+1</td>
<td>4</td>
<td>1 组失效</td>
<td>½ n × S</td>
<td>高 – 近似 RAID0 性能 (无故障)</td>
<td>高 – 近似 RAID0 性能 (无故障)</td>
<td>先条带后镜像。性能佳但故障后风险高。实际不常用，通常用 RAID10 代替。</td>
</tr>
<tr>
<td>RAID 1+0</td>
<td>4</td>
<td>每组 1 盘</td>
<td>½ n × S</td>
<td>高 – 接近 RAID0，随机读表现优秀</td>
<td>高 – 略低于 RAID0，随机写大幅优于 RAID5&#x2F;6</td>
<td>综合性能和容错均优秀。适合数据库等高 I&#x2F;O 应用。可承受非同组多盘故障。</td>
</tr>
<tr>
<td>RAID 50</td>
<td>6</td>
<td>每组 1 盘</td>
<td>(n - 组数) × S</td>
<td>高 – 多组并行，顺序读写优异</td>
<td>中等 – 组内写有校验，组间并行提升</td>
<td>多用于 &gt;6 盘的大型阵列，提升性能和重建并行度。容忍各组各 1 盘故障。</td>
</tr>
<tr>
<td>RAID 60</td>
<td>8</td>
<td>每组 2 盘</td>
<td>(n - 2×组数) × S</td>
<td>高 – 多组并行，顺序性能佳</td>
<td>中等偏低 – 组内双校验影响写入</td>
<td>超大型阵列使用，提供双重冗余和高吞吐。容忍各组各 2 盘故障。</td>
</tr>
<tr>
<td>RAID-DP</td>
<td>3-?</td>
<td>2</td>
<td>(n - 2) × S</td>
<td>高 – 类似 RAID4&#x2F;5 水平</td>
<td>中 – NetApp 优化后接近 RAID10</td>
<td>NetApp 专有双校验 RAID，企业存储默认配置。性能几乎不减，安全性高。</td>
</tr>
<tr>
<td>RAID-Z1&#x2F;Z2&#x2F;Z3</td>
<td>3&#x2F;4&#x2F;5</td>
<td>1&#x2F;2&#x2F;3</td>
<td>(n - 1&#x2F;2&#x2F;3) × S</td>
<td>高 – 近似 RAID5&#x2F;6 读性能</td>
<td>中 – 动态条带改善小写性能</td>
<td>ZFS 文件系统专用，消除 RAID5 写漏洞。单盘到三盘冗余可选，适合 NAS。</td>
</tr>
</tbody></table>
<p><strong>表注</strong>：上表中 n 表示阵列中磁盘总数。读写性能以相对于单盘的理论值表示，实际效能会因实现算法和工作负载不同而有所差异。RAID 10&#x2F;50&#x2F;60 等组合级别的容量公式需根据具体分组方式计算，表中给出的公式假定各组大小均等且使用标准奇偶算法。JBOD 列出的性能和安全性类似于不带冗余的 RAID 0。</p>
<h2 id="RAID-的实现与配置方法"><a href="#RAID-的实现与配置方法" class="headerlink" title="RAID 的实现与配置方法"></a>RAID 的实现与配置方法</h2><p>RAID 可通过软件或硬件两种方式实现。软件 RAID 由操作系统或软件层管理阵列；硬件 RAID 则由独立的 RAID 控制器（包含处理器 &#x2F; 缓存）来管理阵列，对系统透明。下面分别介绍常见的软件 RAID 配置和硬件 RAID 配置方法。</p>
<h3 id="软件-RAID-配置"><a href="#软件-RAID-配置" class="headerlink" title="软件 RAID 配置"></a>软件 RAID 配置</h3><h4 id="Linux-软件-RAID（mdadm）"><a href="#Linux-软件-RAID（mdadm）" class="headerlink" title="Linux 软件 RAID（mdadm）"></a>Linux 软件 RAID（mdadm）</h4><p>在 Linux 系统中，可使用内核提供的多设备阵列驱动（md）和工具 mdadm 来创建 RAID。配置步骤概述如下：</p>
<ol>
<li><p><strong>准备磁盘 &#x2F; 分区</strong>：确保待加入 RAID 的硬盘已连接，并对它们进行分区（可直接使用整盘或创建等大的分区）。多个磁盘最好容量相近，否则 RAID 容量会以最小盘为准。</p>
</li>
<li><p><strong>创建阵列</strong>：使用 mdadm 命令创建 RAID 设备。例如，要创建一个包含 3 块磁盘的 RAID5 阵列，可以执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mdadm --create /dev/md0 --level=5 --raid-devices=3 /dev/sda1 /dev/sdb1 /dev/sdc1</span><br></pre></td></tr></table></figure>
<p>其中 <code>/dev/md0</code> 是虚拟阵列设备，<code>--level=5</code> 指定 RAID5，<code>--raid-devices=3</code> 指定成员数，后面列出组成阵列的分区或磁盘。创建命令会触发构建过程，内核开始计算奇偶校验并初始化阵列（可以通过 <code>watch cat /proc/mdstat</code> 查看进度）。</p>
</li>
<li><p><strong>创建文件系统并挂载</strong>：阵列设备建好后，像对待普通磁盘一样格式化（例如 <code>mkfs.ext4 /dev/md0</code>），然后挂载到系统某个挂载点即可使用。</p>
</li>
<li><p><strong>配置开机自动组装</strong>：编辑 <code>/etc/mdadm/mdadm.conf</code> 添加阵列信息，并更新 initramfs（某些发行版自动完成）。这样重启时阵列会自动装配。同时可在 <code>/etc/fstab</code> 中添加阵列的挂载信息确保自动挂载。</p>
</li>
<li><p><strong>监控和管理</strong>：<code>mdadm</code> 也用于后续管理，如查看状态（<code>mdadm -D /dev/md0</code>）、添加 &#x2F; 移除磁盘、设置热备盘（<code>--add</code> 命令）等。当阵列发生磁盘故障，<code>mdadm</code> 会发送内核事件，可配置 <code>mdadm --monitor</code> 或系统日志及时获知。更换故障盘后，用 <code>mdadm --add</code> 将新盘加入阵列进行重建。</p>
</li>
</ol>
<p>Linux 的软件 RAID 具有良好性能和灵活性，可以实现 0,1,4,5,6,10 等级别，甚至支持在运行中调整阵列（如扩容 RAID5）。但需要消耗主机 CPU 进行校验计算。在现代 CPU 性能充裕的情况下，一般中低负载场景软件 RAID 绰绰有余。</p>
<h4 id="Windows-软件-RAID（存储空间-动态磁盘）"><a href="#Windows-软件-RAID（存储空间-动态磁盘）" class="headerlink" title="Windows 软件 RAID（存储空间 &#x2F; 动态磁盘）"></a>Windows 软件 RAID（存储空间 &#x2F; 动态磁盘）</h4><p>Windows 操作系统提供了软件 RAID 功能，主要有两种实现方式：</p>
<ol>
<li><strong>动态磁盘模式（Legacy）</strong>：在早期 Windows 和当前专业版 Windows 中，可通过“磁盘管理”将基本磁盘转换为动态磁盘，从而创建带区卷（Striped, RAID0）、镜像卷（Mirrored, RAID1）或 RAID-5 卷。例如，在磁盘管理中选择两个空闲磁盘区可以创建一个镜像卷，实现 RAID1；选择三块动态磁盘可创建 RAID-5 卷。动态磁盘的 RAID 功能比较基础，例如 RAID5 卷仅在 Windows 服务器 &#x2F; 专业版可用，且管理不如现代方案便利。目前微软不再增强动态磁盘功能。</li>
<li>**存储空间 (Storage Spaces)**：这是 Windows 8&#x2F;10 及 Windows Server 提供的存储池功能。用户可以将多块磁盘加入一个存储池，然后在池上创建虚拟磁盘，指定所需的容错模式：例如“双向镜像”（2 盘镜像，相当于 RAID1）、“三向镜像”（3 副本）、“奇偶”（单奇偶 RAID5 类似）或“双奇偶”（类似 RAID6，两盘冗余）。存储空间支持精简配置和自动重新平衡等功能，使用 PowerShell 可以更细粒度控制列数（条带宽度）等参数。对于一般用户，通过控制面板或服务器管理器的向导即可配置。例如创建一个包含 4 盘的存储池，再新建一个“双奇偶”的虚拟盘，即得到一个具有两盘容错的冗余卷（类似 RAID6 的功能）。</li>
</ol>
<p>Windows 软件 RAID 的配置通常比较直观，但需要注意版本限制（如 Win10 家用版不支持创建镜像卷）。存储空间在 Windows Server 系统中功能更强大，可替代部分硬件 RAID 需求。</p>
<p><strong>其他软件 RAID 方案</strong>：除上述，某些操作系统或应用也提供软件 RAID 能力。例如 FreeBSD 的 gmirror&#x2F;graid，Linux 的 LVM 也能做 striping 或镜像（结合 md 更灵活），以及 UNRAID 等软件定义存储方案等。原则上软件 RAID 都依赖主机资源运行，优势是成本低、灵活方便。</p>
<p><strong>软件 RAID 配置要点</strong>：使用软件 RAID 需确保硬盘连接稳定（直连 SATA&#x2F;SAS 或 JBOD 背板），并留意不要让主板的假 RAID 功能和软件 RAID 冲突。尽量在安装操作系统之前规划好阵列或使用能够在线迁移的方案。定期监控阵列状态，尤其在消费级操作系统上软件 RAID 故障通知可能不明显，需主动检查。</p>
<h3 id="硬件-RAID-配置"><a href="#硬件-RAID-配置" class="headerlink" title="硬件 RAID 配置"></a>硬件 RAID 配置</h3><p>硬件 RAID 由专用的 RAID 控制器卡或主板上的 RAID 芯片负责管理阵列。硬件 RAID 控制器有自己的处理器和缓存，能在阵列上实现复杂运算且对操作系统透明（OS 看到的只是一块“大硬盘”）。配置硬件 RAID 一般通过控制卡的 BIOS&#x2F;UEFI 设置界面或厂商提供的管理软件完成：</p>
<ol>
<li><strong>安装 RAID 控制器 &#x2F; 硬盘连接</strong>：对于主板自带 RAID（如常见的 Intel RST、AMD RAID），在 BIOS 中启用 RAID 模式并将硬盘接到主板对应接口上。对于独立 RAID 卡（如 Dell PERC、LSI MegaRAID 等），将卡插入 PCIe 插槽并连接硬盘 &#x2F; 背板。启动服务器时通常会显示 RAID 卡 BIOS 提示，如“Press Ctrl+R to enter RAID Configuration”。</li>
<li><strong>进入 RAID 设置界面</strong>：根据提示按下特定组合键进入 RAID 控制器的固件配置菜单。不同厂商界面略有不同，但基本提供创建阵列、删除阵列、查看阵列等选项。</li>
<li><strong>创建 RAID 阵列</strong>：选择“创建阵列”（Create Array &#x2F; Create Virtual Disk 等）。然后选择要包含在阵列中的物理硬盘驱动器。通常可以选择将所有剩余盘都加入，或只选部分盘。</li>
<li><strong>选择 RAID 级别</strong>：在可用 RAID 级别列表中，选定所需的 RAID 级别（0, 1, 5, 6, 10, 50, 60 等，具体取决于控制器型号支持）。控制器会根据所选级别和硬盘数验证是否可行（例如选 RAID5 需要至少 3 盘）。</li>
<li><strong>设置阵列参数</strong>：通常可以设置条带大小（Stripe Size，如 64KB、128KB 等，影响顺序 IO 性能）、读写缓存策略（如 Write-Back 开关，如果控制器有电池 &#x2F; 闪存保护则可安全启用 Write-Back 缓存来提升写性能）、初始化方式（快速或全面初始化奇偶校验）等。还有些支持配置热备盘（Global Hot Spare），可指定某盘为全局热备，在任一阵列盘故障时自动介入重建。</li>
<li><strong>确认并创建</strong>：保存配置，控制器将开始初始化阵列。如果是 RAID1&#x2F;5&#x2F;6 等有冗余的级别，通常需要初始化校验（写入零校验或同步镜像）——许多卡允许后台初始化，不影响先行使用阵列。创建完成后，控制器会将该阵列呈现给系统，主机 BIOS 会检测到一个新的逻辑驱动器。</li>
<li><strong>系统使用</strong>：重启后，操作系统应能识别出这个逻辑磁盘。之后就像普通硬盘一样分区、格式化、安装系统或存储数据。如果是引导阵列，通常需要在安装操作系统时加载相应的 RAID 驱动（尤其独立 RAID 卡在 Windows 安装时需要提供驱动）。</li>
<li><strong>管理维护</strong>：硬件 RAID 通常提供 OS 下管理工具或 web 界面（例如 MegaRAID Storage Manager）用于监控阵列健康、设置告警、管理重建等。也可以通过控制器 BIOS 监视。硬件 RAID 卡自带蜂鸣器或 LED 指示灯，可以指示故障硬盘的位置。发生硬盘故障时，控制器会自动使用热备盘（如果配置了）进行重建，或者等待管理员更换坏盘后手动触发重建。硬件 RAID 重建速度通常较快，因为控制器有专用处理器执行校验计算。</li>
</ol>
<p><strong>硬件 RAID 的优缺点</strong>：</p>
<ul>
<li><strong>优点</strong>：对 CPU 零占用、性能强劲（特别是带缓存和专用 ASIC 的高端卡，可加速校验计算），并且阵列管理独立于操作系统（阵列信息保存在卡和磁盘上，迁移到相同型号控制器上通常能直接识别阵列）。另外，一些硬件 RAID 提供高级功能如在线扩容、阵列级别迁移、快照等。</li>
<li><strong>缺点</strong>：成本较高，专业 RAID 卡价格不菲且可能需要电池 &#x2F; 备用电源模块保障缓存安全；不同厂商实现有所差异，阵列难以跨品牌迁移；另外 RAID 卡本身也是单点，如果卡硬件故障且无法找到兼容替代，可能会导致阵列暂时不可用。</li>
</ul>
<p><strong>主板集成 RAID（又称 Fake RAID）注意</strong>：主板 BIOS 提供的 RAID 功能实际上介于软硬件之间——它依赖 BIOS 和驱动协同工作，并不具备独立处理器，大部分计算仍由 CPU 完成。此类 RAID 的好处是无需额外成本，坏处是兼容性和灵活性略差（例如换主板可能无法直接读阵列，需要相同芯片组），在 Linux 下往往还不如直接用 mdadm。对于桌面用户，主板 RAID 可用性一般，但在高级环境中更倾向于纯软件 RAID 或购买独立 RAID 卡。</p>
<p>总之，配置硬件 RAID 时务必保持相关文档在手，了解阵列的正确管理方法，特别是更换盘和升级固件要谨慎。硬件 RAID 控制器通常在性能和可靠性上表现出色，适合关键的企业应用场景。</p>
<h2 id="RAID-级别选择指南"><a href="#RAID-级别选择指南" class="headerlink" title="RAID 级别选择指南"></a>RAID 级别选择指南</h2><p>面对不同数量的硬盘、应用需求和容错要求，应选择合适的 RAID 级别来平衡性能、容量和可靠性。以下是一些推荐原则和典型情形下的 RAID 选择建议：</p>
<h3 id="不同磁盘数量下的-RAID-选择"><a href="#不同磁盘数量下的-RAID-选择" class="headerlink" title="不同磁盘数量下的 RAID 选择"></a>不同磁盘数量下的 RAID 选择</h3><ul>
<li><strong>只有单盘或容量不匹配多盘</strong>：可以选择不使用 RAID 或 JBOD。单盘无冗余，重要数据需做好备份。多块不同大小盘可以独立使用（JBOD 独立模式）或拼接成一个卷。如果追求最大容量且容错不重要，可用 JBOD 拼接来合并空间；但任一盘坏会影响整体卷，谨慎用于关键数据。</li>
<li><strong>2 块硬盘</strong>：可选 RAID 1 或 RAID 0。如果数据重要需要冗余，RAID 1 镜像是唯一选择，能在一盘损坏时保护数据，但容量只有一半。若更看重性能或空间且有备份，可选 RAID 0 实现两盘条带化（读写性能翻倍，容量相加）。例如，系统盘或重要资料盘建议 RAID1，游戏或非关键高速存储可用 RAID0。</li>
<li><strong>3 块硬盘</strong>：可考虑 RAID 5（2 盘数据 + 1 盘校验）。RAID 5 在 3 盘时提供冗余（可坏 1 盘）且比镜像利用率高（可用容量 2 盘，总容量的 66%）。适用于容量需求较大又希望有一定容错的小型存储。如果性能要求不高且想要最大容量，也可以 3 盘 JBOD 或 RAID0（不过任何一盘坏都会丢失数据，风险很高，不推荐存放重要数据）。另外，3 盘也可做 RAID 1 的“三盘镜像”（每盘都有相同数据），但这种用法少见且利用率低，仅在需要多个实时备份拷贝时才用。</li>
<li><strong>4 块硬盘</strong>：常见选择有 RAID 5、RAID 6、RAID 10：<ul>
<li><strong>RAID 5</strong>：提供 1 盘冗余，可用容量 3 盘，利用率 75%。适合以读为主、希望较大容量的场景。</li>
<li><strong>RAID 6</strong>：提供 2 盘冗余，可用容量 2 盘，利用率 50%。双冗余使安全性更高，但有效容量较少，4 盘 RAID6 在容量效率上不如直接两对 RAID1 镜像（也是 50%）——但 RAID6 胜在可容忍同时两盘故障而 RAID10 在 4 盘情况下只允许一对坏两盘。一般而言，4 盘阵列若非常看重可靠性，可选 RAID6；否则 RAID5 或 RAID10 会在性能或容量上更有优势。</li>
<li><strong>RAID 10</strong>：2 对镜像再条带，可坏每对各一盘（最多坏 2 盘，容错略次于 RAID6 需分布恰当），容量 2 盘（利用率 50%）。RAID10 在 4 盘时提供了 RAID6 级别的冗余能力（耐 2 盘故障，但要分别在不同对）以及优于 RAID5&#x2F;6 的随机写性能，非常适合如数据库等需要高 IOPS 和可靠性的应用。不过可用容量只有 RAID5 的 2&#x2F;3。</li>
<li><strong>推荐</strong>：若应用写入较多、要求高性能，4 盘用 RAID10；若应用读多写少、需要容量，4 盘 RAID5 较优；如果非常担心双盘同时故障（比如长时间无人值守环境），可以接受 50% 容量换安全，则 RAID6 是稳妥的方案。</li>
</ul>
</li>
<li><strong>5～6 块硬盘</strong>：随着磁盘增多，可以考虑 RAID 5 vs RAID 6 vs RAID 10 权衡：<ul>
<li>5 盘 RAID5 可用 4 盘容量（80%），RAID6 可用 3 盘容量 (60%)，RAID10 可用 2.5 盘容量 (50%)。若需求容量为先，RAID5 的空间效率最高，但只能抗 1 盘坏，5 盘阵列稍有风险；RAID6 略降容量但提供双盘保护，常被认为更安全的选择尤其在 6 盘时（6 盘 RAID6 可坏 2 盘，利用率 ~67%）。RAID10 在 5 盘无法实现（需偶数盘），在 6 盘时可用 3 盘容量 (50%)，性能出众且可抗故障灵活（可坏 3 盘，概率依故障分布）。</li>
<li><strong>推荐</strong>：一般 5 盘阵列建议用 RAID5（折中成本），但一定要做好备份；6 盘阵列更倾向于 RAID6（兼顾容量和安全）或 RAID10（对性能要求极高时）。例如，一个 6 盘的 NAS 用于备份存储，RAID6 会比 RAID5 更安心；而 6 盘做数据库 OLTP 存储，或需要很多随机写操作，则 RAID10 可能更适合。</li>
</ul>
</li>
<li><strong>8 块硬盘左右</strong>：可考虑 RAID 6 或 RAID 10，也可以探索 RAID 50&#x2F;60：<ul>
<li>8 盘单 RAID6 可用 6 盘容量 (75%)，抗 2 盘故障；8 盘 RAID10 可用 4 盘容量 (50%)，抗故障能力取决于分布（最好情况 4 盘坏）；8 盘 RAID50 可比如分成两组 4 盘 RAID5 条带，可用 6 盘容量 (75%)，任两组各 1 盘坏（甚至一组坏 1 盘另一组坏 1 盘，总 2 盘坏）仍安全，但若一组坏 2 盘就失败；8 盘 RAID60 可分两组 4 盘 RAID6 条带，可用 4 盘容量 (50%)，任意每组最多坏 2 盘安全，甚至可能承受 4 盘坏（两组各 2 盘）。</li>
<li><strong>推荐</strong>：如果追求最大容量且接受一定风险，可用 RAID6（是大多数 NAS&#x2F;存储在 8 盘左右的默认推荐）；如果追求性能或更高冗余，可考虑 RAID10，但代价是损失一半空间；如果有明确需求提升重建速度或 I&#x2F;O 并行，8 盘可以尝试 2 组 4 盘 RAID50：容量 75%，性能较高，但注意单组双盘故障风险；RAID60 则除非特别保守，一般不在仅 8 盘时使用（因为容量效率太低，RAID10 反而更简单高效）。</li>
</ul>
</li>
<li><strong>超过 10 块硬盘以上</strong>：阵列规模较大时，更应关注数据安全和重建窗口风险。此时推荐：<ul>
<li>RAID 6 或 RAID 60 优先于 RAID5，双盘冗余可以防范在重建长过程中第二盘故障的灾难。</li>
<li>RAID 60 vs RAID 6：如果有硬件支持，多组 RAID6（RAID60）能将比如 16-24 盘划分成更小组管理，减少每组盘数以加快重建和降低多盘同组损坏概率。但 RAID60 利用率比单 RAID6 低一些，需要更多冗余盘。选择上，如果有 20 盘，做一个 18+2 RAID6 利用率 90% 但万一第三盘坏全丢；而做两组 9+2 RAID60 利用率 80% 但每组抗 2 盘坏且第三盘坏也未必丢（需同组第三盘坏才出问题），可靠性更强。对于关键业务，宁愿牺牲一些容量采用 RAID60 获得更高数据保障。</li>
<li>RAID 50 vs RAID 6：对于一些对性能要求较高的大阵列（尤其顺序 IO），RAID50 提供的并行优势更明显。如果系统有良好备份或容灾措施，也可以选择 RAID50 以获得比 RAID6 更好的写入性能和稍高容量。但要做好监控，确保及时更换故障盘，避免单组双盘故障。</li>
<li>RAID 10 &#x2F; 100：当磁盘非常多且应用极端重视性能（例如超大数据库、高频交易系统），可以考虑镜像 + 条带的多层次，例如 16 盘可以做 8 对镜像再条带（RAID10），32 盘甚至可以做两层：先镜像成 16 对，再把 16 对分成两组条带，然后两组再条带（这有时称 RAID100）。虽然利用率低（50%），但随机 I&#x2F;O 性能和数据安全都非常高（可容忍大量跨不同对的磁盘故障）。缺点是成本和空间代价巨大。一般只有在磁盘容量相对廉价且性能要求压倒一切时才会选如此配置。</li>
</ul>
</li>
</ul>
<h3 id="特殊考虑"><a href="#特殊考虑" class="headerlink" title="特殊考虑"></a>特殊考虑</h3><ul>
<li><strong>ZFS 等文件系统自带 RAID 方案</strong>：如果使用 ZFS 等有自己 RAID 方案的系统，优先采用 RAID-Z 系列而非硬件 RAID，将冗余交给文件系统管理，这样可以利用 ZFS 完整性校验、快照等特性，减少不同层次干扰。使用 RAID-Z 需要保证有足够内存和合理的 vdev 规划，比如不要一个 vdev 放太多盘（宁多 vdev 分摊）。典型 TrueNAS 配置如 12 盘可做 2 个 6 盘 RAID-Z2 vdev 组成池，兼顾可靠性和性能。</li>
<li>**热备盘 (Hot Spare)**：无论哪种 RAID 配置，若有剩余磁盘接口和预算，建议配置热备盘。热备盘是在阵列空闲待命的盘，一旦某阵列成员盘失败，控制器会自动把热备投入使用并开始重建，这可缩短阵列在降级状态下的时间，降低数据再次失效风险。一般 RAID5&#x2F;6 阵列至少配置 1 个全局热备盘较为稳妥。</li>
</ul>
<h3 id="最终选择建议"><a href="#最终选择建议" class="headerlink" title="最终选择建议"></a>最终选择建议</h3><p>最后，选择 RAID 级别需要结合具体应用：</p>
<ul>
<li><strong>数据库、虚拟化</strong>：这类小随机读写繁重的应用，更倾向 RAID 10。RAID 10 提供了高性能和高可靠性，适合需要高 IOPS 和快速读写性能的场景。</li>
<li><strong>文件共享、归档</strong>：这类顺序读多于写的应用，RAID 5&#x2F;6 提供更大容量且性能足够。RAID 5&#x2F;6 在顺序读取性能上表现良好，同时提供了适当的冗余保护。</li>
<li><strong>家庭 NAS</strong>：磁盘不多时，RAID 1 简单可靠，适合存放个人重要数据。当磁盘数量较多时，RAID 5&#x2F;6&#x2F;ZFS 更合适，能够提供更大的存储空间和冗余保护。</li>
<li><strong>企业关键数据</strong>：一般至少采用 RAID6 级别冗余，宁可多花磁盘成本，以确保数据的安全性和可靠性。</li>
</ul>
<p><strong>重要提醒</strong>：无论选择哪种 RAID 级别，RAID 都不是备份手段。重要数据请一定另外备份或异地容灾，即使最高级别的 RAID 也无法抵御人为误删或灾难性损坏。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wiki.stxwer.top">3kk0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wiki.stxwer.top/2025/05/26/raid/">https://wiki.stxwer.top/2025/05/26/raid/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wiki.stxwer.top" target="_blank">Akisec</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Raid/">Raid</a></div><div class="post-share"><div class="social-share" data-image="https://pic.stxwer.top/2025/05/26/6834259507497.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.bootcdn.net/butterfly-extsrc/1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.bootcdn.net/butterfly-extsrc/1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/05/09/obsidian/" title="自托管 Obsidian 多端同步服务器"><img class="cover" src="https://pic.stxwer.top/2025/05/09/681dccddc5019.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">自托管 Obsidian 多端同步服务器</div></div><div class="info-2"><div class="info-item-1">自托管 Obsidian 多端同步服务器的完整方案，通过 CouchDB 搭建 Obsidian LiveSync 同步服务器，涵盖从部署 CouchDB、配置 HTTPS 反向代理，到 Obsidian 中配置 LiveSync 插件全过程。</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://pic.stxwer.top/2025/05/12/6821c234b7c34.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">3kk0</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/aceak"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to Akisec</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RAID-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">RAID 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAID-%E7%BA%A7%E5%88%AB%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">RAID 级别分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84-RAID-%E7%BA%A7%E5%88%AB%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">各 RAID 级别详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-0-%E2%80%93-%E6%9D%A1%E5%B8%A6%E5%8C%96%E5%AD%98%E5%82%A8%EF%BC%88Striping%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">RAID 0 – 条带化存储（Striping）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-1-%E2%80%93-%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%EF%BC%88Mirroring%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">RAID 1 – 磁盘镜像（Mirroring）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-2-%E2%80%93-%E6%B1%89%E6%98%8E%E7%A0%81%E6%A0%A1%E9%AA%8C%EF%BC%88Hamming-Code-ECC%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">RAID 2 – 汉明码校验（Hamming Code ECC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-3-%E2%80%93-%E5%AD%97%E8%8A%82%E4%BA%A4%E9%94%99%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%EF%BC%88Byte-Interleaved-Parity%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">RAID 3 – 字节交错奇偶校验（Byte-Interleaved Parity）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-4-%E2%80%93-%E7%8B%AC%E7%AB%8B%E5%9D%97%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%EF%BC%88Dedicated-Parity-with-Block-Striping%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">RAID 4 – 独立块奇偶校验（Dedicated Parity with Block Striping）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-5-%E2%80%93-%E5%88%86%E5%B8%83%E5%BC%8F%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%EF%BC%88Distributed-Parity%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">RAID 5 – 分布式奇偶校验（Distributed Parity）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-6-%E2%80%93-%E5%8F%8C%E9%87%8D%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%EF%BC%88Double-Distributed-Parity%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">RAID 6 – 双重奇偶校验（Double Distributed Parity）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-0-1-%EF%BC%88RAID-01%EF%BC%89%E2%80%93-%E5%85%88%E6%9D%A1%E5%B8%A6%E5%90%8E%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">3.8.</span> <span class="toc-text">RAID 0+1 （RAID 01）– 先条带后镜像的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-1-0-%EF%BC%88RAID-10%EF%BC%89-%E2%80%93-%E5%85%88%E9%95%9C%E5%83%8F%E5%90%8E%E6%9D%A1%E5%B8%A6%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">3.9.</span> <span class="toc-text">RAID 1+0 （RAID 10） – 先镜像后条带的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-50-%E2%80%93-%E6%9D%A1%E5%B8%A6%E5%8C%96%E7%9A%84-RAID-5-%E7%BB%84%E5%90%88"><span class="toc-number">3.10.</span> <span class="toc-text">RAID 50 – 条带化的 RAID 5 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-60-%E2%80%93-%E6%9D%A1%E5%B8%A6%E5%8C%96%E7%9A%84-RAID-6-%E7%BB%84%E5%90%88"><span class="toc-number">3.11.</span> <span class="toc-text">RAID 60 – 条带化的 RAID 6 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JBOD-%E2%80%93-%E7%8B%AC%E7%AB%8B%E7%A3%81%E7%9B%98-%E5%B9%B6%E5%88%97%E7%9B%98%E7%BB%84-Just-a-Bunch-of-Disks"><span class="toc-number">3.12.</span> <span class="toc-text">JBOD – 独立磁盘 &#x2F; 并列盘组 (Just a Bunch of Disks)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-DP-%E2%80%93-%E5%8F%8C%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%9A%84%E4%B8%93%E6%9C%89%E5%AE%9E%E7%8E%B0-NetApp-RAID-DP"><span class="toc-number">3.13.</span> <span class="toc-text">RAID-DP – 双奇偶校验的专有实现 (NetApp RAID-DP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-Z-%E2%80%93-%E5%8A%A8%E6%80%81%E6%9D%A1%E5%B8%A6%E7%9A%84-ZFS-RAID-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.14.</span> <span class="toc-text">RAID-Z – 动态条带的 ZFS RAID 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84-RAID-%E7%BA%A7%E5%88%AB%E7%89%B9%E6%80%A7%E5%AF%B9%E6%AF%94"><span class="toc-number">4.</span> <span class="toc-text">各 RAID 级别特性对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAID-%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">RAID 的实现与配置方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6-RAID-%E9%85%8D%E7%BD%AE"><span class="toc-number">5.1.</span> <span class="toc-text">软件 RAID 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E8%BD%AF%E4%BB%B6-RAID%EF%BC%88mdadm%EF%BC%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">Linux 软件 RAID（mdadm）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-%E8%BD%AF%E4%BB%B6-RAID%EF%BC%88%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4-%E5%8A%A8%E6%80%81%E7%A3%81%E7%9B%98%EF%BC%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">Windows 软件 RAID（存储空间 &#x2F; 动态磁盘）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6-RAID-%E9%85%8D%E7%BD%AE"><span class="toc-number">5.2.</span> <span class="toc-text">硬件 RAID 配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAID-%E7%BA%A7%E5%88%AB%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97"><span class="toc-number">6.</span> <span class="toc-text">RAID 级别选择指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%A3%81%E7%9B%98%E6%95%B0%E9%87%8F%E4%B8%8B%E7%9A%84-RAID-%E9%80%89%E6%8B%A9"><span class="toc-number">6.1.</span> <span class="toc-text">不同磁盘数量下的 RAID 选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%80%83%E8%99%91"><span class="toc-number">6.2.</span> <span class="toc-text">特殊考虑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-number">6.3.</span> <span class="toc-text">最终选择建议</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/26/raid/" title="RAID级别介绍和配置指南"><img src="https://pic.stxwer.top/2025/05/26/6834259507497.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RAID级别介绍和配置指南"/></a><div class="content"><a class="title" href="/2025/05/26/raid/" title="RAID级别介绍和配置指南">RAID级别介绍和配置指南</a><time datetime="2025-05-26T08:21:19.000Z" title="发表于 2025-05-26 16:21:19">2025-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/09/obsidian/" title="自托管 Obsidian 多端同步服务器"><img src="https://pic.stxwer.top/2025/05/09/681dccddc5019.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自托管 Obsidian 多端同步服务器"/></a><div class="content"><a class="title" href="/2025/05/09/obsidian/" title="自托管 Obsidian 多端同步服务器">自托管 Obsidian 多端同步服务器</a><time datetime="2025-05-09T04:00:00.000Z" title="发表于 2025-05-09 12:00:00">2025-05-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://pic.stxwer.top/2025/05/09/681dd5c91e0a1.webp);"><div id="footer-wrap"><div class="copyright">&copy;2025 By 3kk0</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><script src="/js/tw_cn.js?v=5.3.5"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const el = document.getElementById("waline-wrap");
  var idPath = el.getAttribute('comment_id');
  if (!idPath) {
    idPath = decodeURI(window.location.pathname);
  }
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"emoji":["https://unpkg.com/@waline/emojis@1.2.0/bilibili","https://unpkg.com/@waline/emojis@1.2.0/qq","https://unpkg.com/@waline/emojis@1.2.0/bmoji","https://unpkg.com/@waline/emojis@1.2.0/alus"]}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://wiki.stxwer.top/comment',
      serverURL: 'https://wiki.stxwer.top/comment',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      imageUploader: (file) => {
          if (!file) {  
            throw new Error('No file provided');  
          }  
          let formData = new FormData();
          let headers = new Headers();
          formData.append('file', file);
          formData.append('album_id', 1);
          headers.set('Authorization', 'Bearer 3|WUbcVr15mujflNmLVjS5NiSTkf4yzrNoAt2Jn8bb');
          headers.set('Accept', 'application/json');
          return fetch('https://pics.stxwer.top/api/v1/upload', {
            method: 'POST',
            headers: headers,
            body: formData,
            mode: 'cors',
          })
            .then((resp) => resp.json())
            .then((resp) => resp.data.links.url);
        },
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.bootcdn.net/ajax/libs/waline/3.5.0/waline.css')
        .then(() => import('https://cdn.bootcdn.net/ajax/libs/waline/3.5.0/waline.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>